<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>加密项密码生成器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #333;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2575fc 0%, #6a11cb 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .content {
            padding: 25px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #2575fc;
            box-shadow: 0 0 0 3px rgba(37, 117, 252, 0.1);
        }

        .generate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #2575fc, #6a11cb);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .generate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(37, 117, 252, 0.4);
        }

        .generate-btn:active {
            transform: translateY(-1px);
        }

        .result {
            margin-top: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 2px dashed #dee2e6;
            transition: all 0.3s;
        }

        .result-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .password {
            font-size: 28px;
            font-weight: bold;
            color: #212529;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-all;
        }

        .copy-btn {
            width: 100%;
            padding: 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .copy-btn.copied {
            background: #17a2b8;
        }

        .instructions {
            margin-top: 25px;
            background: #e7f3ff;
            border-radius: 10px;
            padding: 15px;
            font-size: 14px;
            color: #0c5460;
            border-left: 4px solid #2575fc;
        }

        .instructions h3 {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 480px) {
            .container {
                border-radius: 15px;
            }

            .header {
                padding: 20px;
            }

            .content {
                padding: 20px;
            }

            .password {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1><i class="fas fa-key"></i> 加密项密码生成器</h1>
        <p>输入参数生成专属加密密码</p>
    </div>

    <div class="content">
        <div class="input-group">
            <label for="param1"><i class="fas fa-tag"></i> VIN码</label>
            <input type="text" id="param1" placeholder="请输入第一个参数">
        </div>

        <div class="input-group">
            <label for="param2"><i class="fas fa-tag"></i> 随机数</label>
            <input type="text" id="param2" placeholder="请输入第二个参数">
        </div>

        <button class="generate-btn" id="generateBtn">
            <i class="fas fa-cogs"></i> 生成密码
        </button>

        <div class="result" id="result">
            <div class="result-label">
                <i class="fas fa-lock"></i> 生成的密码
            </div>
            <div class="password" id="password">
                请输入参数并点击生成
            </div>
        </div>

        <button class="copy-btn" id="copyBtn">
            <i class="fas fa-copy"></i> 复制密码
        </button>

        <div class="instructions">
            <h3><i class="fas fa-info-circle"></i> 使用说明</h3>
            <ul>
                <li>输入两个参数后点击"生成密码"按钮</li>
                <li>系统将根据参数生成专属加密密码</li>
                <li>点击"复制密码"按钮可快速复制生成的密码</li>
                <li>密码生成算法可根据需求自定义</li>
            </ul>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const generateBtn = document.getElementById('generateBtn');
        const copyBtn = document.getElementById('copyBtn');
        const param1Input = document.getElementById('param1');
        const param2Input = document.getElementById('param2');
        const passwordElement = document.getElementById('password');
        const resultElement = document.getElementById('result');

        // 生成密码按钮点击事件
        generateBtn.addEventListener('click', async function() {
            const param1 = param1Input.value.trim();
            const param2 = param2Input.value.trim();

            if (!param1 || !param2) {
                passwordElement.textContent = '请填写两个参数';
                resultElement.style.borderColor = '#ffc107';
                return;
            }
            // === 1. 参数验证 ===
            if (!param1 || param1.length !== 17) {
                passwordElement.textContent = 'VIN码必须为17位';
                resultElement.style.borderColor = '#ffc107';
                return;
            }
            if (!param2 || param2.length !== 4 || !/^\d{4}$/.test(param2)) {
                passwordElement.textContent = '随机数必须为4位数字';
                resultElement.style.borderColor = '#ffc107';
                return;
            }
            // 显示生成中状态
            passwordElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成中...';

            const password = await generatePassword(param1, param2);
            passwordElement.textContent = password;
            resultElement.style.borderColor = '#28a745';

            // 重置复制按钮状态
            copyBtn.innerHTML = '<i class="fas fa-copy"></i> 复制密码';
            copyBtn.classList.remove('copied');

        });

        // 复制密码按钮点击事件
        copyBtn.addEventListener('click', function() {
            const password = passwordElement.textContent;

            if (!password || password === '请输入参数并点击生成' || password.includes('生成中') || password === '请填写两个参数') {
                return;
            }

            // 使用现代剪贴板API
            navigator.clipboard.writeText(password).then(() => {
                copyBtn.innerHTML = '<i class="fas fa-check"></i> 已复制';
                copyBtn.classList.add('copied');

                // 3秒后恢复原状
                setTimeout(() => {
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i> 复制密码';
                    copyBtn.classList.remove('copied');
                }, 3000);
            }).catch(err => {
                console.error('复制失败:', err);
                alert('复制失败，请手动选择密码文本进行复制');
            });
        });

        // 输入框回车键支持
        [param1Input, param2Input].forEach(input => {
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    generateBtn.click();
                }
            });
        });
    });

    /**
     * 使用Web Crypto API计算AES128-CMAC
     * @param {string} vin - 17位车辆识别码 (VIN)
     * @param {string} randomNum - 4位数字随机数
     * @returns {Promise<string>} 16字节CMAC的十六进制字符串
     */
    async function generatePassword(vin, randomNum) {
        // === 固定参数 ===
        const PUBLIC_KEY = "31697060FAA6B4D5A5AD1C4D9A3BD07A"; // 32字符十六进制密钥 (16字节)
        const CONSTANT = "0123"; // 4位常量

        // === 1. 参数验证 ===
        //if (!vin || vin.length !== 17) {
        //	throw new Error('VIN码必须为17位');
        //}
        //if (!randomNum || randomNum.length !== 4 || !/^\d{4}$/.test(randomNum)) {
        //	throw new Error('随机数必须为4位数字');
        //}

        // 验证密钥格式
        //if (!/^[0-9a-fA-F]{32}$/.test(PUBLIC_KEY)) {
        //	throw new Error('密钥格式错误，必须为32位十六进制字符');
        //}

        // === 2. 准备密钥和消息 ===
        // 转换密钥为字节数组
        const keyBytes = hexStringToBytes(PUBLIC_KEY);

        // 组合消息: VIN + 随机数 + 常量
        const message = vin + randomNum + CONSTANT;

        // === 3. 计算CMAC ===
        try {
            //准备密钥（16字节）
            const keyBytes = hexStringToBytes(PUBLIC_KEY);

            //准备数据：VIN + 随机数 + 常量
            const message = vin + randomNum + CONSTANT;
            const data = new TextEncoder().encode(message);

            //使用PKCS#11风格的CMAC计算
            const cmacBytes = await simulatePkcs11CMAC(keyBytes, data);

            //转换为十六进制字符串
            const fullCmac = bytesToHex(cmacBytes);

            //截取后6位作为最终密码
            return fullCmac.slice(-6);
        } catch (error) {
            throw new Error(`CMAC计算失败: ${error.message}`);
        }
    }

    /**
     * 模拟PKCS#11的C_Sign行为生成AES-CMAC
     * 更贴近C语言代码的行为
     */
    async function simulatePkcs11CMAC(keyBytes, dataBytes) {
        // PKCS#11的AES-CMAC通常会返回16字节（128位）的结果
        const BLOCK_SIZE = 16;

        // 1. 验证参数
        if (!(keyBytes instanceof Uint8Array) || keyBytes.length !== 16) {
            throw new Error('密钥必须是16字节');
        }
        if (!(dataBytes instanceof Uint8Array)) {
            throw new Error('数据必须是Uint8Array');
        }

        try {
            // 2. 使用Web Crypto API的AES-CMAC（如果可用）
            // 注意：浏览器Web Crypto API不直接支持AES-CMAC
            // 我们需要使用更接近PKCS#11行为的实现

            // 首先尝试使用AES-CBC模拟，但使用正确的CMAC算法
            return await computeAesCmacPkcs11Style(keyBytes, dataBytes);

        } catch (error) {
            console.error('PKCS#11风格CMAC计算失败:', error);
            throw error;
        }
    }

    /**
     * 使用更接近PKCS#11的方式计算AES-CMAC
     */
    async function computeAesCmacPkcs11Style(keyBytes, dataBytes) {
        const BLOCK_SIZE = 16;
        const Rb = 0x87; // AES-CMAC常数

        // 1. 导入密钥
        const cryptoKey = await crypto.subtle.importKey(
            'raw',
            keyBytes,
            { name: 'AES-CBC' },
            false,
            ['encrypt']
        );

        // 2. 生成子密钥（标准AES-CMAC算法）
        const { k1, k2 } = await generateSubkeysPkcs11(cryptoKey, keyBytes);

        // 3. 处理数据块
        const dataLen = dataBytes.length;
        const blockCount = Math.ceil(dataLen / BLOCK_SIZE);

        // 4. 处理最后一个块（关键部分）
        let lastBlock = new Uint8Array(BLOCK_SIZE);

        if (dataLen === 0) {
            // 空消息
            lastBlock[0] = 0x80;
            xorBytes(lastBlock, k2);
        } else {
            const lastBlockStart = (blockCount - 1) * BLOCK_SIZE;
            const lastBlockLength = dataLen - lastBlockStart;

            if (lastBlockLength === BLOCK_SIZE) {
                // 完整块
                lastBlock.set(dataBytes.slice(lastBlockStart));
                xorBytes(lastBlock, k1);
            } else {
                // 不完整块，需要填充
                lastBlock.set(dataBytes.slice(lastBlockStart, dataLen));
                lastBlock[lastBlockLength] = 0x80;
                // 填充部分已经是0
                xorBytes(lastBlock, k2);
            }
        }

        // 5. CBC-MAC计算
        let iv = new Uint8Array(BLOCK_SIZE); // 全零IV

        // 加密前面的块（如果有）
        if (blockCount > 1) {
            const blocksToEncrypt = dataBytes.slice(0, (blockCount - 1) * BLOCK_SIZE);
            const ciphertext = await crypto.subtle.encrypt(
                { name: 'AES-CBC', iv },
                cryptoKey,
                blocksToEncrypt
            );
            const ciphertextBytes = new Uint8Array(ciphertext);
            iv = ciphertextBytes.slice(-BLOCK_SIZE); // 最后一个密文块作为新的IV
        }

        // 加密最后一块
        const finalCiphertext = await crypto.subtle.encrypt(
            { name: 'AES-CBC', iv },
            cryptoKey,
            lastBlock
        );

        // 6. 返回最后16字节作为CMAC
        const finalBytes = new Uint8Array(finalCiphertext);
        return finalBytes.slice(finalBytes.length - BLOCK_SIZE);
    }

    /**
     * PKCS#11风格的子密钥生成
     */
    async function generateSubkeysPkcs11(cryptoKey, keyBytes) {
        const BLOCK_SIZE = 16;
        const Rb = 0x87;

        // 加密全零块得到L
        const zeroBlock = new Uint8Array(BLOCK_SIZE);
        const iv = new Uint8Array(BLOCK_SIZE);

        const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-CBC', iv },
            cryptoKey,
            zeroBlock
        );

        const L = new Uint8Array(encrypted).slice(0, BLOCK_SIZE);

        // 生成K1
        const k1 = new Uint8Array(L);
        const carry1 = leftShiftOneBitInPlace(k1);
        if (carry1) {
            k1[BLOCK_SIZE - 1] ^= Rb;
        }

        // 生成K2
        const k2 = new Uint8Array(k1);
        const carry2 = leftShiftOneBitInPlace(k2);
        if (carry2) {
            k2[BLOCK_SIZE - 1] ^= Rb;
        }

        return { k1, k2 };
    }

    /**
     * 左移一位（原地操作）
     */
    function leftShiftOneBitInPlace(bytes) {
        let carry = 0;
        for (let i = bytes.length - 1; i >= 0; i--) {
            const newCarry = (bytes[i] & 0x80) !== 0 ? 1 : 0;
            bytes[i] = (bytes[i] << 1) & 0xFF;
            if (carry) {
                bytes[i] |= 1;
            }
            carry = newCarry;
        }
        return carry;
    }

    /**
     * 字节数组异或（原地操作）
     */
    function xorBytes(target, source) {
        for (let i = 0; i < target.length && i < source.length; i++) {
            target[i] ^= source[i];
        }
    }
    // 辅助函数保持不变
    function hexStringToBytes(hexString) {
        if (!/^[0-9a-fA-F]{32}$/.test(hexString)) {
            throw new Error('密钥格式错误，必须为32位十六进制字符');
        }
        const bytes = new Uint8Array(16);
        for (let i = 0; i < 32; i += 2) {
            bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
        }
        return bytes;
    }

    function bytesToHex(bytes) {
        return Array.from(bytes)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    }
</script>
</body>
</html>
